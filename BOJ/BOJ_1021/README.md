# BOJ 1021 - 회전하는 큐

## 1. 핵심 아이디어
- 덱(deque)에 1..N을 넣고, 뽑아야 할 값 x의 현재 위치 index를 찾는다.
- 왼쪽 회전(index번) vs 오른쪽 회전(sz-index번) 중 더 적은 쪽을 선택해 회전 횟수를 누적한다.
- 회전 후 x가 front에 오면 pop_front()로 제거하고 다음 목표로 진행한다.

## 2. 불변식 (Invariant)
- 매 단계에서 dq는 “남아있는 원소들의 상대적 순서”를 유지한 채 원형 회전만 수행하며, 회전이 끝나면 목표값 x가 항상 dq.front()에 위치한다.

## 3. 시간 복잡도
- 시간: O(MN) (각 단계에서 find O(N) + 회전 최악 O(N))
- 공간: O(N)

## 4. 내가 한 실수 / 주의할 점
- size_t(dq.size())와 int(index)를 섞어 쓰면 signed/unsigned 변환 이슈가 생길 수 있음(경고/잠재 버그).
- index == sz-index (정확히 반반)인 경우 기준(>, >=)을 의도적으로 정해야 함(어느 쪽이든 최소는 동일).
- find 결과를 int에 담는 경우 범위가 큰 문제에서는 타입 손실 가능(보통 ptrdiff_t 고려).

## 5. 복습 질문 (Active Recall)
1. 목표값 x의 위치 index를 알 때, 왼쪽/오른쪽 회전 횟수는 각각 어떻게 계산하는가?
2. index == sz-index 인 경우 어느 방향을 골라도 최소가 되는 이유는?
3. “회전 후 반드시 x가 front에 온다”를 보장하는 불변식은 무엇인가?
4. size_t와 int를 섞어 쓰면 어떤 문제가 생기며, 안전한 처리 방법은?