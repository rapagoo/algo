# BOJ 5430 - AC

## 1. 핵심 아이디어
- R(뒤집기)를 실제로 수행하지 않고, `reversed` 플래그로 “논리적 방향”만 토글한다.
- D(버리기)는 `reversed` 상태에 따라 `pop_front()` 또는 `pop_back()`으로 처리한다.
- 에러는 “D를 수행해야 하는데 덱이 비어있는 순간” 즉시 발생시킨다.

## 2. 불변식 (Invariant)
- `dq`는 현재 남아있는 원소들을 담고 있고, `reversed=false`이면 논리적 front가 `dq.front()`, `reversed=true`이면 논리적 front가 `dq.back()`이다. D는 항상 “논리적 front”를 1개 제거한다.

## 3. 시간 복잡도
- 시간: O(|s| + |p| + n)  (파싱 + 연산 + 출력, 필요 시 reverse 포함)
- 공간: O(n)

## 4. 내가 한 실수 / 주의할 점
- 파싱 로직이 문제 조건(1 ≤ xi ≤ 100)에 의존한다(0이 없어서 `cur!=0` 조건이 안전). 조건이 바뀌면 깨질 수 있다.
- `reversed`일 때 `reverse(dq)`로 실제 뒤집는 대신, 출력만 역방향 순회하면 추가 O(n)을 줄일 수 있다.
- 빈 덱에서 D를 수행하면 즉시 `error` 출력해야 한다(중간에 더 연산이 남아도).

## 5. 복습 질문 (Active Recall)
1. R을 실제로 뒤집지 않고 처리하는 핵심 불변식은 무엇인가?
2. `reversed=true`일 때 D는 왜 `pop_back()`이 되는가?
3. 어떤 조건에서 `error`가 발생하며, 왜 그 시점에 즉시 중단해도 되는가?
4. `reverse()` 없이 출력만으로 정답을 만들려면 어떤 방식으로 순회해야 하는가?